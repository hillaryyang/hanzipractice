<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Hanzi Practice</title>
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&family=Noto+Sans+SC:wght@400;700;900&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <header class="global-header">
    <div class="header-content">
      <div class="header-left">
        <h1 class="app-title">Hanzi Practice</h1>
        <div class="header-info">
          <select id="deckSelector" class="deck-selector">
            <option value="HSK 1">HSK 1</option>
            <option value="HSK 2">HSK 2</option>
            <option value="HSK 3">HSK 3</option>
            <option value="HSK 4">HSK 4</option>
            <option value="HSK 5">HSK 5</option>
            <option value="HSK 6">HSK 6</option>
          </select>
        </div>
      </div>
      <div class="header-right">
        <button id="btnTheme" class="theme-toggle" title="Toggle theme">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
          </svg>
        </button>
      </div>
    </div>
  </header>

  <div class="app">
    <aside>
      <div class="char-head">
        <div class="big-char" id="bigChar">Â≠¶</div>
        <div class="pinyin" id="pinyin">xu√©</div>
      </div>

      <div class="stat-grid">
        <div class="stat"><div class="label">Meaning</div><div class="value" id="meaning">to study; learn</div></div>
      </div>

      <div class="btn-row">
        <button id="btnStroke" title="Open a stroke order search" class="ghost">‚ñ∂ Stroke order</button>
        <button id="btnHint" class="ghost">üí° Hint</button>
      </div>

      <div class="hint-pill">Tip: hold <span class="kbd">H</span> to see the outline, <span class="kbd">‚å´</span> to clear, arrows for next/prev.</div>
    </aside>

    <main>
      <div class="board-wrap" id="board">
        <div class="grid-bg"></div>
        <canvas id="bgLayer"></canvas>
        <canvas id="drawLayer"></canvas>
      </div>

      <div class="toolbar">
        <div class="left-tools">
          <button id="btnUndo"> Undo</button>
          <button id="btnClear"> Clear</button>
        </div>
        <div class="right-tools">
          <button id="btnPrev">‚èÆ Prev </button>
          <button id="btnNext">‚è≠ Next</button>
        </div>
      </div>
    </main>
  </div>

<script src="characters.js"></script>
<script>
/* =====================
   Minimal Hanzi practice
   Single-file app for GitHub Pages
   ‚Äî Features ‚Äî
   ‚Ä¢ Apple Pencil / touch / mouse drawing
   ‚Ä¢ Hint overlay (hold H or toggle)
   ‚Ä¢ ‚ÄúCheck‚Äù compares your ink to a bold glyph mask
   ‚Ä¢ Next/Prev through a small built-in deck (editable)
   ‚Ä¢ Works completely offline on GH Pages (no build tools)
===================== */

// --- Character deck (edit/add as you like) ---
let currentDeckName = "HSK 1";
let DECK = [];  // Start with empty array

window.addEventListener('hskDataLoaded', (event) => {
  const { level } = event.detail;
  console.log(`HSK ${level} data loaded event received`);
  
  // If this is the currently selected level, update the deck
  if (currentDeckName === `HSK ${level}`) {
    DECK = CHARACTER_DECKS[currentDeckName] || [];
    console.log(`Updated DECK for ${currentDeckName}, length:`, DECK.length);
    
    if (DECK.length > 0) {
      current = 0;
      setEntry(current);
    }
  }
});

// Add deck change handler
deckSelector.addEventListener('change', async (e) => {
  const selectedDeck = e.target.value;
  const level = selectedDeck.split(' ')[1]; // Extract number from "HSK 1"
  
  // Show loading state
  bigChar.textContent = "‚è≥";
  pinyin.textContent = "Loading...";
  meaning.textContent = "Loading HSK " + level + " vocabulary...";
  exZh.textContent = "";
  exEn.textContent = "";
  
  try {
    // Load the level data if not already loaded
    await window.loadHSKLevel(parseInt(level));
    
    // Update current deck
    currentDeckName = selectedDeck;
    DECK = CHARACTER_DECKS[currentDeckName] || [];
    current = 0;
    
    if (DECK.length > 0) {
      setEntry(0);
    } else {
      console.error('No characters found for', currentDeckName);
      meaning.textContent = "No single characters found for " + selectedDeck;
    }
  } catch (error) {
    console.error('Failed to load HSK level:', error);
    bigChar.textContent = "‚ùå";
    pinyin.textContent = "Error";
    meaning.textContent = "Failed to load HSK " + level + " vocabulary";
    exZh.textContent = "Please check your internet connection";
    exEn.textContent = "";
  }
});

// DOM
const bigChar = document.getElementById('bigChar');
const pinyin  = document.getElementById('pinyin');
const meaning = document.getElementById('meaning');
const exZh    = document.getElementById('exZh');
const exEn    = document.getElementById('exEn');
const btnStroke = document.getElementById('btnStroke');
const btnHint   = document.getElementById('btnHint');
const btnTheme = document.getElementById('btnTheme');
const btnUndo   = document.getElementById('btnUndo');
const btnClear  = document.getElementById('btnClear');
const btnPrev   = document.getElementById('btnPrev');
const btnNext   = document.getElementById('btnNext');

// Canvas setup
const board    = document.getElementById('board');
const bgLayer  = document.getElementById('bgLayer');   // grid + (optional) outline
const drawLayer= document.getElementById('drawLayer'); // user ink only
let bgCtx, drawCtx;
let dpr = Math.max(1, window.devicePixelRatio || 1);

// Offscreen mask for scoring
let maskCanvas = document.createElement('canvas');
let maskCtx    = maskCanvas.getContext('2d', { willReadFrequently: true });

let current = 0;           // index in DECK
let showHint = false;      // toggle
let drawing = false;       // drawing state
let last = null;           // last point
let penWidth = 6;          // base width (scaled by pressure)
let undoStack = [];

function resizeCanvases(){
  const rect = board.getBoundingClientRect();
  const W = Math.floor(rect.width  * dpr);
  const H = Math.floor(rect.height * dpr);

  for (const c of [bgLayer, drawLayer, maskCanvas]){
    c.width = W; c.height = H;
    c.style.width = rect.width + 'px';
    c.style.height= rect.height + 'px';
  }
  bgCtx   = bgLayer.getContext('2d');
  drawCtx = drawLayer.getContext('2d');
  drawCtx.lineCap = 'round';
  drawCtx.lineJoin= 'round';

  redrawBackground();
  drawMaskForChar(DECK[current]);
}

function redrawBackground(){
  const ctx = bgCtx; const W = bgLayer.width, H = bgLayer.height;
  ctx.clearRect(0,0,W,H);
  if (showHint){
    // faint character outline for guidance
    ctx.save();
    ctx.globalAlpha = 0.10;
    drawGlyph(ctx, DECK[current].char, W, H, true);
    ctx.restore();
  }
}

function drawMaskForChar(entry) {
  if (!entry || !entry.char) {
    console.log('Cannot draw mask: invalid entry', entry);
    return;
  }
  
  const W = maskCanvas.width, H = maskCanvas.height;
  maskCtx.clearRect(0,0,W,H);
  drawGlyph(maskCtx, entry.char, W, H, false);
}

// Draws a big centered glyph into the given context.
// If outline==true, we stroke instead of fill (for nicer hint).
function drawGlyph(ctx, char, W, H, outline){
  ctx.save();
  const pad = Math.min(W,H) * 0.12;   // inner padding
  const size = Math.min(W,H) - pad*2; // font size in pixels
  ctx.translate(W/2, H/2);
  const styles = getComputedStyle(document.documentElement);
  const textColor = styles.getPropertyValue('--muted').trim();
  ctx.fillStyle = textColor;
  ctx.strokeStyle = textColor;
  // Use a heavy weight for a thicker mask band to be forgiving
  ctx.font = `900 ${size}px \"Noto Sans SC\", \"PingFang SC\", \"Hiragino Sans GB\", STHeiti, sans-serif`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  if (outline){
    ctx.lineWidth = Math.max(4, size * 0.02);
    ctx.strokeText(char, 0, 0);
  }else{
    ctx.fillText(char, 0, 0);
  }
  ctx.restore();
}

function setEntry(i) {
  if (!DECK || DECK.length === 0) {
    console.log('No deck data available yet');
    bigChar.textContent = "‚è≥";
    pinyin.textContent = "Loading...";
    meaning.textContent = "Loading vocabulary...";
    exZh.textContent = "";
    exEn.textContent = "";
    return;
  }
  
  current = (i + DECK.length) % DECK.length;
  const e = DECK[current];
  
  // Check if entry has required properties
  if (!e || !e.char) {
    console.error('Invalid entry:', e);
    return;
  }
  
  console.log('Setting entry:', e); // Debug log
  
  bigChar.textContent = e.char; 
  pinyin.textContent = e.pinyin || '';
  meaning.textContent = e.meaning || ''; 
  exZh.textContent = e.exampleZh || ''; 
  exEn.textContent = e.exampleEn || '';
    
  clearInk();
  redrawBackground();
  drawMaskForChar(e);
  undoStack = [];
  updateUndoButton();
}

function clearInk(){
  drawCtx.clearRect(0,0,drawLayer.width,drawLayer.height);
  undoStack = [];
  updateUndoButton();
}

function saveCanvasState(){
  const imageData = drawCtx.getImageData(0, 0, drawLayer.width, drawLayer.height);
  undoStack.push(imageData);
  // Keep only last 20 states to prevent memory issues
  if (undoStack.length > 20) {
    undoStack.shift();
  }
  updateUndoButton();
}

function undo(){
  if (undoStack.length > 0) {
    const imageData = undoStack.pop();
    drawCtx.putImageData(imageData, 0, 0);
    updateUndoButton();
  }
}

function updateUndoButton(){
  btnUndo.disabled = undoStack.length === 0;
  btnUndo.style.opacity = undoStack.length === 0 ? '0.5' : '1';
}

// Drawing handlers (pointer events)
function toCanvasPoint(ev, target){
  const rect = target.getBoundingClientRect();
  const x = (ev.clientX - rect.left) * dpr;
  const y = (ev.clientY - rect.top)  * dpr;
  return {x,y};
}

function pointerDown(ev){
  const rect = drawLayer.getBoundingClientRect();
  const x = ev.clientX - rect.left;
  const y = ev.clientY - rect.top;
  
  // Check if click is within the 20px margin (inner drawing area)
  if (x < 20 || y < 20 || x > rect.width - 20 || y > rect.height - 20) {
    return; // Don't start drawing outside the inner area
  }

  saveCanvasState();
  
  drawing = true; 
  drawLayer.setPointerCapture(ev.pointerId);
  last = toCanvasPoint(ev, drawLayer);
}

function pointerMove(ev){
  if (!drawing) return;
  
  const rect = drawLayer.getBoundingClientRect();
  const x = ev.clientX - rect.left;
  const y = ev.clientY - rect.top;
  
  // Stop drawing if we move outside the inner area
  if (x < 20 || y < 20 || x > rect.width - 20 || y > rect.height - 20) {
    drawing = false;
    last = null;
    return;
  }
  
  const pt = toCanvasPoint(ev, drawLayer);
  const pressure = Math.max(0.2, ev.pressure || 0.5);
  drawCtx.lineWidth = penWidth * dpr * (0.6 + pressure*0.8);
  const styles = getComputedStyle(document.documentElement);
  const inkColor = styles.getPropertyValue('--text').trim();
  drawCtx.strokeStyle = inkColor;
  drawCtx.beginPath();
  drawCtx.moveTo(last.x, last.y);
  drawCtx.lineTo(pt.x, pt.y);
  drawCtx.stroke();
  last = pt;
}
function pointerUp(ev){
  drawing = false; last = null;
}

// UI actions
btnHint.addEventListener('click', ()=>{ showHint = !showHint; redrawBackground(); });
btnClear.addEventListener('click', clearInk);
btnUndo.addEventListener('click', undo);
btnPrev.addEventListener('click', ()=> setEntry(current-1));
btnNext.addEventListener('click', ()=> setEntry(current+1));
btnTheme.addEventListener('click', ()=>{
  const currentTheme = document.documentElement.getAttribute('data-theme');
  const newTheme = currentTheme === 'light' ? null : 'light';
  document.documentElement.setAttribute('data-theme', newTheme || 'dark');
  localStorage.setItem('theme', newTheme || 'dark');
});
btnStroke.addEventListener('click', ()=>{
  const c = DECK[current].char;
  const q = encodeURIComponent(`chinese/${c}`);
  window.open(`https://www.strokeorder.com/${q}`, '_blank');
});

// Keyboard shortcuts
window.addEventListener('keydown', (e)=>{
  if (e.key === 'h' || e.key === 'H'){ showHint = true; redrawBackground(); }
  if (e.key === 'Backspace'){ e.preventDefault(); clearInk(); }
  if (e.key === 'ArrowLeft'){ setEntry(current-1); }
  if (e.key === 'ArrowRight'){ setEntry(current+1); }
  if ((e.metaKey || e.ctrlKey) && e.key === 'z'){ e.preventDefault(); undo(); }
});
window.addEventListener('keyup', (e)=>{
  if (e.key === 'h' || e.key === 'H'){ showHint = false; redrawBackground(); }
});

window.addEventListener('hskDataLoaded', (event) => {
  const { level, count, error } = event.detail;
  console.log(`HSK ${level} loaded: ${count} characters${error ? ' (with errors)' : ''}`);
  
  // If this is the currently selected level, refresh the display
  if (currentDeckName === `HSK ${level}`) {
    DECK = CHARACTER_DECKS[currentDeckName];
    if (DECK.length > 0 && current >= DECK.length) {
      current = 0; // Reset if current index is out of bounds
    }
    if (DECK.length > 0) {
      setEntry(current);
    }
  }
  
  // Update the deck selector to show character counts
  const option = deckSelector.querySelector(`option[value="HSK ${level}"]`);
  if (option && count > 0) {
    option.textContent = `HSK ${level} (${count} chars)`;
  }
});

// Pointer events
['pointerdown','pointermove','pointerup','pointercancel','pointerleave'].forEach(type=>{
  drawLayer.addEventListener(type, (ev)=>{
    if (type==='pointerdown') pointerDown(ev);
    else if (type==='pointermove') pointerMove(ev);
    else pointerUp(ev);
  }, {passive:false});
});

// Init
window.addEventListener('resize', resizeCanvases);
resizeCanvases();
// Initialize theme
const savedTheme = localStorage.getItem('theme') || 'dark';
document.documentElement.setAttribute('data-theme', savedTheme);
updateUndoButton();
setEntry(0);

</script>
</body>
</html>