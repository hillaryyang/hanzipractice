<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Hanzi Practice</title>
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&family=Noto+Sans+SC:wght@400;700;900&display=swap" rel="stylesheet">
  <style>
    :root{
      --bg:#0b0e12;           /* page background */
      --panel:#11151b;        /* card/panel */
      --muted:#a8b3cf;        /* secondary text */
      --text:#e7ecf5;         /* main text */
      --accent:#67e8f9;       /* cyan */
      --accent-2:#22d3ee;
      --good:#34d399;         /* green */
      --warn:#f59e0b;         /* amber */
      --bad:#f87171;          /* red */
      --btn:#0f1720;
      --grid:#1b2330;
      --grid-strong:#263141;
    }

    [data-theme="light"]{
      --bg:#f8fafc;
      --panel:#ffffff;
      --muted:#64748b;
      --text:#1e293b;
      --accent:#0ea5e9;
      --accent-2:#0284c7;
      --good:#059669;
      --warn:#d97706;
      --bad:#dc2626;
      --btn:#f1f5f9;
      --grid:#e2e8f0;
      --grid-strong:#cbd5e1;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; font-family:Inter, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji";
      background:var(--bg); color:var(--text);
    }
    .app{display:flex; gap:20px; padding:20px; min-height:100vh}
    aside{width:360px; background:var(--panel); border-radius:16px; padding:16px 16px; display:flex; flex-direction:column; gap:16px}
    .char-head{display:flex; align-items:center; gap:12px}
    .big-char{font-family:"Noto Sans SC", "PingFang SC", "Hiragino Sans GB", STHeiti, system-ui, sans-serif; font-size:44px; line-height:1; background:var(--btn); border:1px solid var(--grid); border-radius:12px; width:64px; height:64px; display:grid; place-items:center}
    .pinyin{background:var(--btn); border:1px solid var(--grid); padding:6px 10px; border-radius:999px; font-weight:600; color:var(--accent)}    .stat-grid{display:grid; grid-template-columns:1fr; gap:12px}
    .stat{background:var(--btn); border:1px solid var(--grid); border-radius:12px; padding:12px}
    .stat .label{font-size:12px; color:var(--muted); letter-spacing:.02em}
    .stat .value{font-weight:700; font-size:18px; margin-top:4px}
    .example{background:var(--btn); border:1px solid var(--grid); border-radius:12px; padding:12px}
    .example .en{color:var(--muted); font-size:14px}
    .btn-row{display:flex; gap:10px}
    button{appearance:none; border:1px solid var(--grid); background:var(--btn); color:var(--text); border-radius:12px; padding:10px 14px; font-weight:600; cursor:pointer; font-size:16px}    button:hover{border-color:var(--grid-strong)}
    button.primary{background:linear-gradient(180deg, var(--accent), var(--accent-2)); color:#05222b; border:none}
    button.ghost{background:var(--btn)}
    button.small{padding:6px 10px; font-size:13px; border-radius:10px}

    main{flex:1; background:var(--panel); border-radius:16px; padding:16px; display:flex; flex-direction:column; min-height:500px;}
    .board-wrap{position:relative; width:400px; height:400px; margin:0 auto; border-radius:12px; overflow:hidden; border:1px solid var(--grid); background:var(--bg)}
    /* tianzige background - 4 quadrants */
    .grid-bg{
      position:absolute; 
      inset:0; 
      background:var(--bg);
    }
    /* Outer border */
    .grid-bg::before{
      content:""; 
      position:absolute; 
      top:20px; left:20px; right:20px; bottom:20px;
      border:2px solid var(--grid-strong);
      border-radius:4px;
    }
    /* Inner tianzige lines */
    .grid-bg::after{
      content:""; 
      position:absolute; 
      top:20px; left:20px; right:20px; bottom:20px;
      background-image:
        /* Vertical center line */
        linear-gradient(90deg, transparent calc(50% - 1px), var(--grid) calc(50% - 1px), var(--grid) calc(50% + 1px), transparent calc(50% + 1px)),
        /* Horizontal center line */
        linear-gradient(0deg, transparent calc(50% - 1px), var(--grid) calc(50% - 1px), var(--grid) calc(50% + 1px), transparent calc(50% + 1px)),
        /* Diagonal lines */
        linear-gradient(45deg, var(--grid) 1px, transparent 1px),
        linear-gradient(-45deg, var(--grid) 1px, transparent 1px);      background-size:
        100% 100%,
        100% 100%, 
        141.42% 141.42%,
        141.42% 141.42%;
      background-position:
        center,
        center,
        center,
        center;
      background-repeat: no-repeat;
    }

    .global-header{
      background: var(--panel);
      border-bottom: 1px solid var(--grid);
      padding: 16px 20px;
      position: sticky;
      top: 0;
      z-index: 100;
    }

    .header-content{
      display: flex;
      justify-content: space-between;
      align-items: center;
      max-width: 1200px;
      margin: 0 auto;
    }

    .header-left{
      display: flex;
      align-items: center;
      gap: 20px;
    }

    .app-title{
      font-size: 20px;
      font-weight: 800;
      margin: 0;
      color: var(--text);
    }

    .header-info{
      display: flex;
      gap: 15px;
      font-size: 14px;
      color: var(--muted);
    }

    .character-counter{
      font-weight: 500;
    }

    .header-right{
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .theme-toggle{
      background: transparent;
      border: none;
      color: var(--muted);
      padding: 8px;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s ease;
      font-size: 0;
    }

    .theme-toggle:hover{
      background: var(--btn);
      color: var(--text);
      border-color: transparent;
    }

    .theme-toggle svg{
      transition: transform 0.3s ease;
    }
    .loading {
      opacity: 0.6;
      pointer-events: none;
    }

    .loading::after {
      content: "";
      position: absolute;
      top: 50%;
      left: 50%;
      width: 20px;
      height: 20px;
      margin: -10px 0 0 -10px;
      border: 2px solid var(--muted);
      border-top: 2px solid var(--accent);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* Select decks */
    .deck-selector{
      background: var(--btn);
      border: 1px solid var(--grid);
      color: var(--text);
      padding: 6px 12px;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
    }

    .deck-selector:focus{
      outline: none;
      border-color: var(--accent);
    }

    [data-theme="light"] .theme-toggle svg{
      transform: rotate(180deg);
    }

    canvas{position:absolute; inset:0; width:100%; height:100%; touch-action:none}
    #bgLayer{z-index:1}
    #drawLayer{z-index:2}

    .toolbar{display:flex; gap:10px; align-items:center; justify-content:space-between; margin-top:12px}
    .left-tools, .right-tools{display:flex; gap:10px; align-items:center}
    .status{font-weight:700}

    .hint-pill{font-size:12px; color:var(--muted)}
    .kbd{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; background:var(--btn); border:1px solid var(--grid); padding:2px 6px; border-radius:6px; font-size:12px; color:var(--text)}

    @media (max-width: 980px){
      .app{flex-direction:column}
      aside{width:auto}
    }
  </style>
</head>
<body>
  <header class="global-header">
    <div class="header-content">
      <div class="header-left">
        <h1 class="app-title">Hanzi Practice</h1>
        <div class="header-info">
          <select id="deckSelector" class="deck-selector">
            <option value="HSK 1">HSK 1</option>
            <option value="HSK 2">HSK 2</option>
            <option value="HSK 3">HSK 3</option>
            <option value="HSK 4">HSK 4</option>
            <option value="HSK 5">HSK 5</option>
            <option value="HSK 6">HSK 6</option>
          </select>
        </div>
      </div>
      <div class="header-right">
        <button id="btnTheme" class="theme-toggle" title="Toggle theme">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
          </svg>
        </button>
      </div>
    </div>
  </header>

  <div class="app">
    <aside>
      <div class="char-head">
        <div class="big-char" id="bigChar">Â≠¶</div>
        <div class="pinyin" id="pinyin">xu√©</div>
      </div>

      <div class="stat-grid">
        <div class="stat"><div class="label">Meaning</div><div class="value" id="meaning">to study; learn</div></div>
      </div>

      <div class="example">
        <div class="label">Example</div>
        <div class="zh" id="exZh">ÊàëÂ≠¶‰∏≠Êñá„ÄÇ</div>
        <div class="en" id="exEn">I study Chinese.</div>
      </div>

      <div class="btn-row">
        <button id="btnStroke" title="Open a stroke order search" class="ghost">‚ñ∂ Stroke order</button>
        <button id="btnHint" class="ghost">üí° Hint</button>
      </div>

      <div class="hint-pill">Tip: hold <span class="kbd">H</span> to see the outline, <span class="kbd">‚å´</span> to clear, arrows for next/prev.</div>
    </aside>

    <main>
      <div class="board-wrap" id="board">
        <div class="grid-bg"></div>
        <canvas id="bgLayer"></canvas>
        <canvas id="drawLayer"></canvas>
      </div>

      <div class="toolbar">
        <div class="left-tools">
          <button id="btnUndo"> Undo</button>
          <button id="btnClear"> Clear</button>
        </div>
        <div class="right-tools">
          <button id="btnPrev">‚èÆ Prev </button>
          <button id="btnNext">‚è≠ Next</button>
        </div>
      </div>
    </main>
  </div>

<script src="characters.js"></script>
<script>
/* =====================
   Minimal Hanzi practice
   Single-file app for GitHub Pages
   ‚Äî Features ‚Äî
   ‚Ä¢ Apple Pencil / touch / mouse drawing
   ‚Ä¢ Hint overlay (hold H or toggle)
   ‚Ä¢ ‚ÄúCheck‚Äù compares your ink to a bold glyph mask
   ‚Ä¢ Next/Prev through a small built-in deck (editable)
   ‚Ä¢ Works completely offline on GH Pages (no build tools)
===================== */

// --- Character deck (edit/add as you like) ---
let currentDeckName = "HSK 1";
let DECK = [];  // Start with empty array

window.addEventListener('hskDataLoaded', (event) => {
  const { level } = event.detail;
  console.log(`HSK ${level} data loaded event received`);
  
  // If this is the currently selected level, update the deck
  if (currentDeckName === `HSK ${level}`) {
    DECK = CHARACTER_DECKS[currentDeckName] || [];
    console.log(`Updated DECK for ${currentDeckName}, length:`, DECK.length);
    
    if (DECK.length > 0) {
      current = 0;
      setEntry(current);
    }
  }
});

// Add deck change handler
deckSelector.addEventListener('change', async (e) => {
  const selectedDeck = e.target.value;
  const level = selectedDeck.split(' ')[1]; // Extract number from "HSK 1"
  
  // Show loading state
  bigChar.textContent = "‚è≥";
  pinyin.textContent = "Loading...";
  meaning.textContent = "Loading HSK " + level + " vocabulary...";
  exZh.textContent = "";
  exEn.textContent = "";
  
  try {
    // Load the level data if not already loaded
    await window.loadHSKLevel(parseInt(level));
    
    // Update current deck
    currentDeckName = selectedDeck;
    DECK = CHARACTER_DECKS[currentDeckName] || [];
    current = 0;
    
    if (DECK.length > 0) {
      setEntry(0);
    } else {
      console.error('No characters found for', currentDeckName);
      meaning.textContent = "No single characters found for " + selectedDeck;
    }
  } catch (error) {
    console.error('Failed to load HSK level:', error);
    bigChar.textContent = "‚ùå";
    pinyin.textContent = "Error";
    meaning.textContent = "Failed to load HSK " + level + " vocabulary";
    exZh.textContent = "Please check your internet connection";
    exEn.textContent = "";
  }
});

// DOM
const bigChar = document.getElementById('bigChar');
const pinyin  = document.getElementById('pinyin');
const meaning = document.getElementById('meaning');
const exZh    = document.getElementById('exZh');
const exEn    = document.getElementById('exEn');
const btnStroke = document.getElementById('btnStroke');
const btnHint   = document.getElementById('btnHint');
const btnTheme = document.getElementById('btnTheme');
const btnUndo   = document.getElementById('btnUndo');
const btnClear  = document.getElementById('btnClear');
const btnPrev   = document.getElementById('btnPrev');
const btnNext   = document.getElementById('btnNext');

// Canvas setup
const board    = document.getElementById('board');
const bgLayer  = document.getElementById('bgLayer');   // grid + (optional) outline
const drawLayer= document.getElementById('drawLayer'); // user ink only
let bgCtx, drawCtx;
let dpr = Math.max(1, window.devicePixelRatio || 1);

// Offscreen mask for scoring
let maskCanvas = document.createElement('canvas');
let maskCtx    = maskCanvas.getContext('2d', { willReadFrequently: true });

let current = 0;           // index in DECK
let showHint = false;      // toggle
let drawing = false;       // drawing state
let last = null;           // last point
let penWidth = 6;          // base width (scaled by pressure)
let undoStack = [];

function resizeCanvases(){
  const rect = board.getBoundingClientRect();
  const W = Math.floor(rect.width  * dpr);
  const H = Math.floor(rect.height * dpr);

  for (const c of [bgLayer, drawLayer, maskCanvas]){
    c.width = W; c.height = H;
    c.style.width = rect.width + 'px';
    c.style.height= rect.height + 'px';
  }
  bgCtx   = bgLayer.getContext('2d');
  drawCtx = drawLayer.getContext('2d');
  drawCtx.lineCap = 'round';
  drawCtx.lineJoin= 'round';

  redrawBackground();
  drawMaskForChar(DECK[current]);
}

function redrawBackground(){
  const ctx = bgCtx; const W = bgLayer.width, H = bgLayer.height;
  ctx.clearRect(0,0,W,H);
  if (showHint){
    // faint character outline for guidance
    ctx.save();
    ctx.globalAlpha = 0.10;
    drawGlyph(ctx, DECK[current].char, W, H, true);
    ctx.restore();
  }
}

function drawMaskForChar(entry) {
  if (!entry || !entry.char) {
    console.log('Cannot draw mask: invalid entry', entry);
    return;
  }
  
  const W = maskCanvas.width, H = maskCanvas.height;
  maskCtx.clearRect(0,0,W,H);
  drawGlyph(maskCtx, entry.char, W, H, false);
}

// Draws a big centered glyph into the given context.
// If outline==true, we stroke instead of fill (for nicer hint).
function drawGlyph(ctx, char, W, H, outline){
  ctx.save();
  const pad = Math.min(W,H) * 0.12;   // inner padding
  const size = Math.min(W,H) - pad*2; // font size in pixels
  ctx.translate(W/2, H/2);
  const styles = getComputedStyle(document.documentElement);
  const textColor = styles.getPropertyValue('--muted').trim();
  ctx.fillStyle = textColor;
  ctx.strokeStyle = textColor;
  // Use a heavy weight for a thicker mask band to be forgiving
  ctx.font = `900 ${size}px \"Noto Sans SC\", \"PingFang SC\", \"Hiragino Sans GB\", STHeiti, sans-serif`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  if (outline){
    ctx.lineWidth = Math.max(4, size * 0.02);
    ctx.strokeText(char, 0, 0);
  }else{
    ctx.fillText(char, 0, 0);
  }
  ctx.restore();
}

function setEntry(i) {
  if (!DECK || DECK.length === 0) {
    console.log('No deck data available yet');
    bigChar.textContent = "‚è≥";
    pinyin.textContent = "Loading...";
    meaning.textContent = "Loading vocabulary...";
    exZh.textContent = "";
    exEn.textContent = "";
    return;
  }
  
  current = (i + DECK.length) % DECK.length;
  const e = DECK[current];
  
  // Check if entry has required properties
  if (!e || !e.char) {
    console.error('Invalid entry:', e);
    return;
  }
  
  console.log('Setting entry:', e); // Debug log
  
  bigChar.textContent = e.char; 
  pinyin.textContent = e.pinyin || '';
  meaning.textContent = e.meaning || ''; 
  exZh.textContent = e.exampleZh || ''; 
  exEn.textContent = e.exampleEn || '';
    
  clearInk();
  redrawBackground();
  drawMaskForChar(e);
  undoStack = [];
  updateUndoButton();
}

function clearInk(){
  drawCtx.clearRect(0,0,drawLayer.width,drawLayer.height);
  undoStack = [];
  updateUndoButton();
}

function saveCanvasState(){
  const imageData = drawCtx.getImageData(0, 0, drawLayer.width, drawLayer.height);
  undoStack.push(imageData);
  // Keep only last 20 states to prevent memory issues
  if (undoStack.length > 20) {
    undoStack.shift();
  }
  updateUndoButton();
}

function undo(){
  if (undoStack.length > 0) {
    const imageData = undoStack.pop();
    drawCtx.putImageData(imageData, 0, 0);
    updateUndoButton();
  }
}

function updateUndoButton(){
  btnUndo.disabled = undoStack.length === 0;
  btnUndo.style.opacity = undoStack.length === 0 ? '0.5' : '1';
}

// Drawing handlers (pointer events)
function toCanvasPoint(ev, target){
  const rect = target.getBoundingClientRect();
  const x = (ev.clientX - rect.left) * dpr;
  const y = (ev.clientY - rect.top)  * dpr;
  return {x,y};
}

function pointerDown(ev){
  const rect = drawLayer.getBoundingClientRect();
  const x = ev.clientX - rect.left;
  const y = ev.clientY - rect.top;
  
  // Check if click is within the 20px margin (inner drawing area)
  if (x < 20 || y < 20 || x > rect.width - 20 || y > rect.height - 20) {
    return; // Don't start drawing outside the inner area
  }

  saveCanvasState();
  
  drawing = true; 
  drawLayer.setPointerCapture(ev.pointerId);
  last = toCanvasPoint(ev, drawLayer);
}

function pointerMove(ev){
  if (!drawing) return;
  
  const rect = drawLayer.getBoundingClientRect();
  const x = ev.clientX - rect.left;
  const y = ev.clientY - rect.top;
  
  // Stop drawing if we move outside the inner area
  if (x < 20 || y < 20 || x > rect.width - 20 || y > rect.height - 20) {
    drawing = false;
    last = null;
    return;
  }
  
  const pt = toCanvasPoint(ev, drawLayer);
  const pressure = Math.max(0.2, ev.pressure || 0.5);
  drawCtx.lineWidth = penWidth * dpr * (0.6 + pressure*0.8);
  const styles = getComputedStyle(document.documentElement);
  const inkColor = styles.getPropertyValue('--text').trim();
  drawCtx.strokeStyle = inkColor;
  drawCtx.beginPath();
  drawCtx.moveTo(last.x, last.y);
  drawCtx.lineTo(pt.x, pt.y);
  drawCtx.stroke();
  last = pt;
}
function pointerUp(ev){
  drawing = false; last = null;
}

// UI actions
btnHint.addEventListener('click', ()=>{ showHint = !showHint; redrawBackground(); });
btnClear.addEventListener('click', clearInk);
btnUndo.addEventListener('click', undo);
btnPrev.addEventListener('click', ()=> setEntry(current-1));
btnNext.addEventListener('click', ()=> setEntry(current+1));
btnTheme.addEventListener('click', ()=>{
  const currentTheme = document.documentElement.getAttribute('data-theme');
  const newTheme = currentTheme === 'light' ? null : 'light';
  document.documentElement.setAttribute('data-theme', newTheme || 'dark');
  localStorage.setItem('theme', newTheme || 'dark');
});
btnStroke.addEventListener('click', ()=>{
  const c = DECK[current].char;
  const q = encodeURIComponent(`chinese/${c}`);
  window.open(`https://www.strokeorder.com/${q}`, '_blank');
});

// Keyboard shortcuts
window.addEventListener('keydown', (e)=>{
  if (e.key === 'h' || e.key === 'H'){ showHint = true; redrawBackground(); }
  if (e.key === 'Backspace'){ e.preventDefault(); clearInk(); }
  if (e.key === 'ArrowLeft'){ setEntry(current-1); }
  if (e.key === 'ArrowRight'){ setEntry(current+1); }
  if ((e.metaKey || e.ctrlKey) && e.key === 'z'){ e.preventDefault(); undo(); }
});
window.addEventListener('keyup', (e)=>{
  if (e.key === 'h' || e.key === 'H'){ showHint = false; redrawBackground(); }
});

window.addEventListener('hskDataLoaded', (event) => {
  const { level, count, error } = event.detail;
  console.log(`HSK ${level} loaded: ${count} characters${error ? ' (with errors)' : ''}`);
  
  // If this is the currently selected level, refresh the display
  if (currentDeckName === `HSK ${level}`) {
    DECK = CHARACTER_DECKS[currentDeckName];
    if (DECK.length > 0 && current >= DECK.length) {
      current = 0; // Reset if current index is out of bounds
    }
    if (DECK.length > 0) {
      setEntry(current);
    }
  }
  
  // Update the deck selector to show character counts
  const option = deckSelector.querySelector(`option[value="HSK ${level}"]`);
  if (option && count > 0) {
    option.textContent = `HSK ${level} (${count} chars)`;
  }
});

// Pointer events
['pointerdown','pointermove','pointerup','pointercancel','pointerleave'].forEach(type=>{
  drawLayer.addEventListener(type, (ev)=>{
    if (type==='pointerdown') pointerDown(ev);
    else if (type==='pointermove') pointerMove(ev);
    else pointerUp(ev);
  }, {passive:false});
});

// Init
window.addEventListener('resize', resizeCanvases);
resizeCanvases();
// Initialize theme
const savedTheme = localStorage.getItem('theme') || 'dark';
document.documentElement.setAttribute('data-theme', savedTheme);
updateUndoButton();
setEntry(0);

</script>
</body>
</html>